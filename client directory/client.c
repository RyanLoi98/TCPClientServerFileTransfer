/*
 * Name: Ryan Loi
 * Date (dd/mm/yyyy): 28/01/2023
 * Lecture: L02
 * Tutorial: T02
 *
 * CPSC 441 Assignment 1 - Client side
 *
 *  The only form of help (very basic questions) obtained was from the TA of Tutorial T02 (Sadaf Erfanmanesh)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <signal.h>


/**
 * Function that will obtain the user's UCID, the function also contains error checking mechanisms to ensure the user
 * enters 8 integer digits for their UCID.
 * @return a UCID comprised of 8 integer digits
 */
int getID(){
    // variable to hold the user's UCID
    int UCID;

    // variable to hold the input string that the user will enter when prompted for their UCID (10 bytes to check for users
    // entering in too many digits)
    char strUCID[10];

    // create flag to control the loop, it will always be true (1) until a valid UCID is entered
    int flag = 1;

    // loop until the user enters a valid 8 digit UCID comprised of only integers
    do {
        // prompt user to enter the UCID:
        printf("Please enter your 8 digit UCID: ");
        // scan for user input, limit it to 10 digits (enough to check if the user entered too many digits)
        scanf("%10s", strUCID);

        // erase the stdin buffer to prevent subsequent scanf's from reading in left over input from the standard in steam
        // this command makes it scan everything up until (and excluding) the \n character and discard all the scanned stuff.
        scanf("%*[^\n]");

        // obtain the length of the user's string input for their UCID, this will be used for error checking later on
        int strUCIDlen = strlen(strUCID);

        // convert string of UCID to an integer, this will also remove any trailing characters or return 0 if the input
        // was all characters or began with characters
        UCID = atoi(strUCID);

        // variable to hold the UCID that is reconverted back to a string, strUCIDlen + 1 to ensure room for \0
        // this will be used to error check to see if the user input contained any characters - which would have been
        // removed by atoi() therefore making this string shorter than the original
        char strUCID2 [strUCIDlen + 1];
        sprintf(strUCID2, "%d", UCID);

        // cases
        // length of strUCID2 != length of strUCID2 --> must have characters
        // length of strUCID2 == length of strUCID2 --> input was an integer so check number of digits!


        // if the length decreased that means the UCID input contained characters, so print an error and loop again
        if(strlen(strUCID2) != strUCIDlen){
            printf("Error: the UCID cannot contain any characters! Please only enter 8 integer digits for your UCID\n\n");

            // if UCID was not 8 digits print an error and reloop
        }else if(strlen(strUCID2) != 8){
            printf("Error: the UCID must be exactly 8 integer digits long!\n\n");

            // otherwise if the UCID was 8 digits long it was valid, so set the flag to false (0)
        }else if (strlen(strUCID2) ==8){
            flag = 0;
        }

    } while (flag);

    return UCID;
}


/**
 * Function to generate an integer passcode based on adding the last 4 digits of the UCID sent from the client to
 * the seconds part of the time that was take on the server
 * @param dateTime: a string containing the date and time generated by the server upon receiving a UCID from the client
 * @param strUCID: string containing the character representation of an 8 digit UCID from the client
 * @return: returns the integer passcode
 */
int generatePass(char dateTime[], char strUCID[]){

    // convert the strUCID into an int, but only get the last 4 digits. To do this use the atoi on the address of the 5th
    // char of the strUCID so it will only convert characters 5-8 (aka the last 4 digits of the UCID) to an integer.
    int UCID = atoi(&strUCID[4]);

    // index for the first digit of the seconds in time
    int ind = 0;

    // loop through the date time string and look for the index corresponding to the first ':' character
    while(ind < strlen(dateTime)){

        // compare the current character indexed from the string dateTime to ':', if they are the same break the loop
        if(dateTime[ind] == ':'){
            break;
        }
        // increment ind by 1
        ind++;
    }

    // due to the layout of the dateTime the first digit of the seconds in the time is 4 characters away from the first
    // ':'and thus it is ind + 4

    // get the integer form of seconds from the dateTime string: to do this first index dateTime with ind + 4. This gets
    // the first character of the seconds in the time. Pass the address of this character to the atoi function, this
    // function will then look at the dateTime string starting from this first character. Since the conversion to an
    // integer performed by this function only includes integers, any trailing non integer characters will be cut off.
    // This leaves only the 2 digits for seconds.
    int seconds = atoi(&dateTime[ind + 4]) ;

    // create the passcode by adding the last 4 digits of the UCID to the seconds
    int passcode = UCID + seconds;

    // return the passcode
    return passcode;
}


/**
 * Main function to execute functionality for the client side of the application
 *
 * @param argc: number of command line arguments given to the program as an integer
 * @param argv: a character array containing the command line arguments given to the program
 * @return: 0 if the program executed successfully, 1 if there was an error during execution
 */
int main(int argc, char *argv[]) {

// commandline argument for port number
    int port;

// variable to hold the error status of various operations
    int errorStatus;

    // blocking all signal pipe errors so that any errors caused by a channel (pipe) being closed can be handled by user
    // written code
    signal(SIGPIPE,SIG_IGN);


    // checking command line arguments

    // if argc == 1 no command line arguments are given for the port number print an error message and exit with error code 1
    if (argc == 1){
        printf("Error: No command line arguments given for port number.\nThe client must be given "
               "at least 1 port number (2000 - 65535) to try and connect to the server on.\n");
        printf("Client shutting down...\n");
        exit(1);

        // otherwise if more than 1 command line arguments are given (argc > 2) for the port number, print an error message that too many
        // command line arguments are given and exit with error code 1
    } else if (argc > 2){
        printf("Error: too many command line arguments are given, enter only 1 port number (2000 - 65535) for the client to connect to the server on\n");
        printf("Client shutting down...\n");
        exit(1);

        // check to see if the command line for port number is valid
    } else{
        // get the length of the port number
        int portLen = strlen(argv[1]);

        // convert the port number from a string to an integer
        port = atoi(argv[1]);

        // atoi returns a 0 if the input was a non integer input, so check to see if the input was invalid
        // if it was invalid, throw an error and exit with error code 1
        if(port == 0){
            printf("Error: the port number cannot have characters or symbols, it must be an integer from 2000 - 65535\n");
            printf("Client shutting down...\n");
            exit(1);
        }

        // convert the port number back into a string, so we can compare lengths with the original input string. This way
        // we can determine if the user entered any additional characters after the port number, which would be removed
        // by the atoi function resulting in the integer getting shorter (size is + 1 to include room for \0)
        char strPort [portLen + 1];
        sprintf(strPort, "%d", port);

        // if the atoi converted port number was shorter than the original input string then throw an error that characters are not allowed
        // and exit with error code 1
        if(portLen != strlen(strPort)) {
            printf("Error: the port number cannot have characters or symbols, it must be an integer from 2000 - 65535\n");
            printf("Client shutting down...\n");
            exit(1);
        }

        // now check to see if the port was in the valid range from 2000 - 65535, if not throw an error and exit with error code 1
        if (port > 65535 || port < 2000){
            printf("Error: port number must be an integer number from 2000 - 65535\n");
            printf("Client shutting down...\n");
            exit(1);
        }
    }



    // address initialization - client side

    // creating a structure (sockaddr_in) called clientAddress
    struct sockaddr_in clientAddress;
    // initialize the clientAddress to zero
    memset(&clientAddress, 0, sizeof(clientAddress));
    // specifies the address family (AF_INET is IPv4 protocol)
    clientAddress.sin_family = AF_INET;
    // specifies port number to be what the user entered via commandline arguments, htson convert from 16 bit host-byte-order to network-byte-order
    clientAddress.sin_port = htons(port);
    //specifies ip address to be 127.0.0.1 (which is the local host IP). The inet_addr converts the ip from
    //"numbers-and-dots notation in CP into binary data in network byte order".
    clientAddress.sin_addr.s_addr = inet_addr("127.0.0.1");



    // socket creation -- client side
    int socket1;
    // domain is AF_INET to make it IPv4 protocol, type is SOCK_STREAM to make it TCP type, 0 for TCP protocol
    socket1 = socket(AF_INET, SOCK_STREAM, 0);
    // check to see if socket1 is -1, if it is then creation failed, so print an error and exit the program with error code 1
    if(socket1 == -1){
        printf("Error: socket creation failed\n");
        printf("Client shutting down...\n");
        exit(1);
    }



    // connection request - client side only

    // call connect on socket1, casting the &clientAddress of our structure to a pointer for the addr param, also pass
    // size of structure we used for creating our structure to the addrlen param
    // then store the status of the connect() function into the errorStatus variable
    errorStatus = connect(socket1, (struct sockaddr*)&clientAddress, sizeof(struct sockaddr_in));

    // check errorStatus, if it is equal to -1 then the connection failed so print out an error and exit with error code 1
    if(errorStatus == -1){
        printf("Error: connection to server on port %d failed\n", port);
        printf("Client shutting down...\n");
        exit(1);
    }

    // Otherwise if execution reaches this point the connection to the server succeeded so prompt the user to enter their UCID
    int UCID = getID();

    // buffer to hold the incoming UCID, 9 bytes in length (which allows for the 8 byte UCID and 1 byte termination character \0)
    char strUCID [9];
    // convert UCID to a string
    sprintf(strUCID, "%d", UCID);



    // sending UCID to the server

    // sCount (send count) variable for number of bits sent as returned by the send function
    int sCount;

    // sending with: socket1, message: strUCID, size of message which is 8 bytes for the 8 characters of the UCID, 0 as the flag
    sCount = send(socket1, strUCID, 9, 0);

    // if sCount == -1 that means the send failed so print an error and exit with error code 1
    if(sCount == -1){
        printf("Error: unable to send UCID to the server on port %d\n", port);
        printf("Client shutting down...\n");
        exit(1);
    }



    // receiving the date and the time from the server

    // rcount (receive count) variable for number of bits received from the server (as returned by the recv function)
    int rCount;

    // buffer to hold the incoming date and time, 100 bytes in length
    char dateTime[100];

    // to recieve: use socket1, dateTime variable to hold the message, 100 for the number of bytes to recieve, and 0 for the flags
    rCount = recv(socket1, dateTime, 100, 0);

    // if rCount == -1 that means the recieve failed, or if rCount == 0 that means the server may have disconnected and
    // thus no data was sent. So in either case print an error and exit with error code 1
    if((rCount == -1) || (rCount == 0)){
        printf("Error: unable to receive the date and time from the server on port %d\n", port);
        printf("Client shutting down...\n");
        exit(1);
    }



    // printing the date and the time
    printf("The time received from the server is: %s\n", dateTime);



    // create the passcode
    int passcode = generatePass(dateTime, strUCID);

    // output the passcode
    printf("The generated passcode to be sent to the server is: %d\n", passcode);



    // sending passcode to the server

    // convert passcode to 6 character string (6 because even if the last 4 digits
    // of the UCID were 9999 and the seconds were 59, the maximum value the passcode could have is 10058 which is 5 digits.
    // Then add 1 extra spot for the termination \0)
    char strPass[6];
    sprintf(strPass, "%d", passcode);

    // reusing the sCount variable to monitor send status
    // sending with: socket1, message: strPass, size of message which is 5 bytes for the maximum 5 characters of the passcode, 0 as the flag
    sCount = send(socket1, strPass, 5, 0);

    // if sCount == -1 that means the send failed so print an error and exit with error code 1
    if(sCount == -1){
        printf("Error: unable to send passcode to the server on port %d\n", port);
        printf("Client shutting down...\n");
        exit(1);
    }



    // creating a pointer to open an output file called "savefile.txt" to write data from the server to
    FILE *outFile = fopen("savefile.txt", "w");

    // check to see if the outFile pointer is null, if it is that means fopen was unable to create the file
    // so print an error message and exit the program with error code 1
    if (outFile == NULL){
        printf("Error: client could not create an output file called \"savefile.txt\" to save data from the server to\n");
        printf("Client shutting down...\n");
        exit(1);
    }

    // create variable to hold the data from the server
    char data [100];


    // getting data from the server to initially prime the data variable

    // to recieve: use socket1, data variable to hold the message, 100 for the number of bytes to recieve, and 0 for the flags
    rCount = recv(socket1, data, 100, 0);

    // reusing the rCount variable to count how many bytes of data is received and if there is a receive error
    // if rCount == -1 that means the recieve failed, or if rCount == 0 the client has recieved no data from the server
    // meaning the server could have disconnected. So in either case print an error and exit with error code 1
    if((rCount == -1) || (rCount == 0)){
        printf("Error: unable to receive transmission data from the server on port %d\n", port);
        printf("Client shutting down...\n");
        exit(1);
    }

    // print out a log of how much data was recieved
    printf("%d bytes received from the Server!\n", rCount);

    // loop until the server sends the special ending flag, in which case strcmp will be == 0
    while (strcmp(data,"\r\r\r\r\rEOF - END oF FiLe hAs beEn rEacHed!!!")!=0){

        // writing to the outFile
        // also check if fprintf returns a value < 0 as that means an error has occurred - in that event an error message
        // will be printed and the program will be exited with error code 1
        if(fprintf(outFile, "%s", data) < 0){
            printf("Error: client was not able to write to the output file \"savefile.txt\", client shutting down... \n\n");
            printf("Client shutting down...\n");
            exit(1);
        }


        // getting more data from the server

        // to recieve: use socket1, data variable to hold the message, 100 for the number of bytes to recieve, and 0 for the flags
        rCount = recv(socket1, data, 100, 0);

        // reusing the rCount variable to count how many bytes of data is received and if there is a receive error
        // if rCount == -1 that means the recieve failed, and if rCount == 0 that means no data was received meaning the
        // server could have disconnected. So in either case print an error and exit with error code 1
        // this will also stop infinite loops if the server disconnects
        if((rCount == -1) || (rCount == 0)){
            printf("Error: unable to receive transmission data from the server on port %d\n", port);
            printf("Client shutting down...\n");
            exit(1);
        }

        // print out a log of how much data was recieved
        printf("%d bytes received from the Server!\n",rCount);
    }

    // closing the socket
    close(socket1);

    // close file
    fclose(outFile);


    return 0;
}
