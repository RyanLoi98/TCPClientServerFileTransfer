/*
 * Name: Ryan Loi
 * Date (dd/mm/yyyy): 28/01/2023
 * Lecture: L02
 * Tutorial: T02
 *
 * CPSC 441 Assignment 1 - Server side
 *
 * The only form of help (very basic questions) obtained was from the TA of Tutorial T02 (Sadaf Erfanmanesh)
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <netdb.h>
#include <time.h>
#include <signal.h>


/**
 * Function to generate an integer passcode based on adding the last 4 digits of the UCID sent from the client to
 * the seconds part of the time that was take on the server
 * @param dateTime: a string containing the date and time generated by the server upon receiving a UCID from the client
 * @param strUCID: string containing the character representation of an 8 digit UCID from the client
 * @return: returns the integer passcode
 */
int generatePass(char dateTime[], char strUCID[]){

    // convert the strUCID into an int, but only get the last 4 digits. To do this use the atoi on the address of the 5th
    // char of the strUCID so it will only convert characters 5-8 (aka the last 4 digits of the UCID) to an integer.
    int UCID = atoi(&strUCID[4]);

    // index for the first digit of the seconds in time
    int ind = 0;

    // loop through the date time string and look for the index corresponding to the first ':' character
    while(ind < strlen(dateTime)){

        // compare the current character indexed from the string dateTime to ':', if they are the same break the loop
        if(dateTime[ind] == ':'){
            break;
        }
        // increment ind by 1
        ind++;
    }

    // due to the layout of the dateTime the first digit of the seconds in the time is 4 characters away from the first
    // ':'and thus it is ind + 4

    // get the integer form of seconds from the dateTime string: to do this first index dateTime with ind + 4. This gets
    // the first character of the seconds in the time. Pass the address of this character to the atoi function, this
    // function will then look at the dateTime string starting from this first character. Since the conversion to an
    // integer performed by this function only includes integers, any trailing non integer characters will be cut off.
    // This leaves only the 2 digits for seconds.
    int seconds = atoi(&dateTime[ind + 4]) ;

    // create the passcode by adding the last 4 digits of the UCID to the seconds
    int passcode = UCID + seconds;

    // return the passcode
    return passcode;
}



int main(int argc, char *argv[]) {

// commandline argument for port number
    int port;
// variable to hold the error status of various operations
    int errorStatus;


    // blocking all signal pipe errors so that any errors caused by a channel (pipe) being closed can be handled by user
    // written code
    signal(SIGPIPE,SIG_IGN);

   // checking command line arguments

   // if argc == 1 no command line arguments are given for the port number print an error message and exit with error code 1
   if (argc == 1){
       printf("Error: No command line arguments given for port number.\nThe server must be given "
              "at least 1 port number (2000 - 65535) to listen to.\n");
       printf("Server shutting down...\n");
       exit(1);

   // otherwise if more than 1 command line arguments are given (argc > 2) for the port number, print an error message that too many
   // command line arguments are given and exit with error code 1
   } else if (argc > 2){
       printf("Error: too many command line arguments are given, enter only 1 port number (2000 - 65535) for the server to listen to\n");
       printf("Server shutting down...\n");
       exit(1);

       // check to see if the command line for port number is valid
   } else{
       // get the length of the port number
       int portLen = strlen(argv[1]);

       // convert the port number from a string to an integer
       port = atoi(argv[1]);

       // atoi returns a 0 if the input was a non integer input, so check to see if the input was invalid
       // if it was invalid, throw an error and exit with error code 1
       if(port == 0){
           printf("Error: the port number cannot have characters or symbols, it must be an integer from 2000 - 65535\n");
           printf("Server shutting down...\n");
           exit(1);
       }

       // convert the port number back into a string, so we can compare lengths with the original input string. This way
       // we can determine if the user entered any additional characters after the port number, which would be removed
       // by the atoi function resulting in the integer getting shorter (size is + 1 to include room for \0)
       char strPort [portLen+1];
       sprintf(strPort, "%d", port);

       // if the atoi converted port number was shorter than the original input string then throw an error that characters are not allowed
       // and exit with error code 1
       if(portLen != strlen(strPort)) {
           printf("Error: the port number cannot have characters or symbols, it must be an integer from 2000 - 65535\n");
           printf("Server shutting down...\n");
           exit(1);
       }

       // now check to see if the port was in the valid range from 2000 - 65535, if not throw an error and exit with error code 1
       if (port > 65535 || port < 2000){
           printf("Error: port number must be an integer number from 2000 - 65535\n");
           printf("Server shutting down...\n");
           exit(1);
       }
   }



   // Address initialization - server side

    // creating a structure (sockaddr_in) called serverAddress
    struct sockaddr_in serverAddress;
    // initialize the serverAddress to zero
    memset(&serverAddress, 0, sizeof(serverAddress));
    // specifies the address family (AF_INET is IPv4 protocol)
    serverAddress.sin_family = AF_INET;
    // specifies port number to be the one the user entered via command line argument, htson convert from 16 bit host-byte-order to network-byte-order
    serverAddress.sin_port = htons(port);
    // specifies the ip address (INADDR_ANY makes it accept any ip address on the local machine). hton1 converts 32 bit host-byte-order to network-byte-order.
    serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);



    // socket creation -- server side
    int socket1;
    // domain is AF_INET to make it IPv4 protocol, type is SOCK_STREAM to make it TCP type, 0 for TCP protocol
    socket1 = socket(AF_INET, SOCK_STREAM, 0);
    // check to see if socket1 is -1, if it is then creation failed, so print an error and exit the program with error code 1
    if(socket1 == -1){
        printf("Error: socket creation failed\n");
        printf("Server shutting down...\n");
        exit(1);
    }



    // binding - server side only

    // errorStatus shows the status of the binding function (-1 bind failed, >0 successful bind)
    // binding with socket1, casting the &address of our structure called address to a pointer for addrport param, then sending the size of the structure we used for serverAddress
    errorStatus = bind(socket1, (struct sockaddr*)
            &serverAddress, sizeof(struct sockaddr_in));

    // if errorStatus is -1 then binding failed and the port could be busy, print out the error and exit with error code 1
    if(errorStatus == -1){
        printf("socket1 binding failed, the selected port (%d) may be busy. Please try again with a different port number\n", port);
        printf("Server shutting down...\n");
        exit(1);
    }



    // looping the server forever
    while (1){

        // Listening - server side only

        // listen to socket 1 for connections, and allow only 1 participant, then update the errorStatus
        errorStatus = listen(socket1,1);

        //Check to see if the listen call had an error (if errorStatus == -1), if so print error message and exit with error code 1
        if(errorStatus==-1){
            printf("Error: Server was unable to listen to port %d. Please pick another port.\n", port);
            printf("Server shutting down...\n");
            exit(1);
        }



        // connection acceptance - server side only

        // creating socket2 for accepted connections
        int socket2;
        // accept using the listening socket (socket1), and use null for last 2 params to prevent storing of the clients
        socket2 = accept(socket1, NULL, NULL);

        // check to see if socket2 == -1, if it is that means the connection acceptance has failed so print an error
        // and then use continue on the while loop to allow for a different client to connect
        if(socket2 == -1){
            printf("Error: Connection acceptance has failed\n");
            printf("Server will now restart and begin listening for new clients\n\n");

            // start while loop again
            continue;
        }



       // recieving the UCID from the client

        // rCount (receive count) variable for number of bits received from the client (as returned by the recv function)
        int rCount;
        // buffer to hold the incoming UCID, 9 bytes in length (which allows for the 8 byte UCID and 1 byte termination character \0)
        char strUCID[9];
        // to recieve: use the accepting socket which is socket 2, UCID variable to hold the message, 8 for the number of bytes to recieve, and 0 for the flags
        rCount = recv(socket2, strUCID, 9, 0);

        // if rCount == -1 that means the receive failed, and if rCount == 0 that means no data was sent from the client
        // and thus the client could have disconnected. So in either case print an error, then close the client socket,
        // and then use continue on the while loop to allow for a different client to connect
        if((rCount == -1) || (rCount == 0)){
            printf("Error: unable to receive a UCID from the client on port %d\n", port);
            printf("Server will now restart and begin listening for new clients...\n\n");

            // closing the client socket
            close(socket2);

            // start loop again
            continue;
        }

        // printing the recieved UCID:
        printf("The UCID received from the client is: %s\n", strUCID);



        // getting the current day and time from the computer
        // variable to contain the current system time (timer arugment is Null)
        time_t systemTime = time(NULL);

        // check to see if there was an error returning time, in which case systemTime = -1. In such a case there is
        // an error with the server itself requiring it to halt functioning. So print an error message, and exit with
        // error code 1
        if (systemTime == ((time_t) -1)){
            printf("Error: The server cannot obtain the system time\n");
            printf("Server shutting down...\n");
            exit(1);
        }

        // convert currentTime into local time which will be stored in a structure allowing us to obtain different
        // parts of the time on its own, for instance just seconds by itself
        struct tm *localTime = localtime(&systemTime);

        // variable to hold the date and time as a string, 100 bytes long to ensure the buffer space never overfills
        char dateTime[100];

        // generate the string containing the date and time in the format: Day of the week, Month, day of the month, time
        // (hh:mm:ss AM/PM) and year.
        strftime (dateTime, 100, "%A, %B %d %I:%M:%S %p %Y", localTime);



        // sending the date and time to the client

        // sCount (send count) variable for number of bits sent as returned by the send function
        int sCount;
        // sending with: socket2, message: dateTime, size of message which is 100 bytes for the dateTime, 0 as the flag
        sCount = send(socket2, dateTime, 100, 0);

        // if sCount == -1 that means the send failed so print an error and then close the socket and use continue on the
        // while loop to enable the server to listen for other clients.
        if(sCount == -1){
            printf("Error: unable to send date and time to the client on port %d\n", port);
            printf("Server will now restart and begin listening for new clients...\n\n");

            // closing the client socket
            close(socket2);

            // start loop again
            continue;
        }



        // create the passcode
        int passcode = generatePass(dateTime, strUCID);



        // recieving the passcode from the client

        // reusing rCount variable
        // buffer to hold the incoming passcode from the server. 6 character string (6 because even if the last 4 digits
        // of the UCID were 9999 and the seconds were 59, the maximum value the passcode could have is 10058 which is 5 digits.
        // Then add 1 extra spot for the termination \0)
        char strPass[6];

        // to recieve: use the accepting socket which is socket 2, strPass variable to hold the message, 5 for the number of bytes
        // to recieve, and 0 for the flags
        rCount = recv(socket2, strPass, 5, 0);

        // if rCount == -1 that means the receive failed, and if rCount == 0 that means no data was sent from the client
        // and thus the client could have disconnected. So in either case print an error, then close the client socket,
        // and then use continue on the while loop to allow for a different client to connect
        if((rCount == -1) || (rCount == 0)){
            printf("Error: unable to receive the passcode from the client on port %d\n", port);
            printf("Server will now restart and begin listening for new clients...\n\n");

            // closing the client socket
            close(socket2);
            // start loop again
            continue;
        }

        // convert the client's passcode into an integer
        int clientPass = atoi(strPass);



        // Check if the client's passcode is the same as server generated passcode, if so begin data transfer process
        if(passcode == clientPass){

            // creating a pointer to open the data.txt file for reading
            FILE *inFile = fopen("data.txt", "r");

            // check to see if the inFile pointer is null, if it is that means fopen was unable to open the file
            // so print an error message and exit the program with error code 1
            if (inFile == NULL){
                printf("Error: server could not open the \"data.txt\" file, ensure this file is in the same directory "
                       "as the server program\nServer shutting down...\n");
                exit(1);
            }


            // create a data variable to hold 100 bytes of data from the data.txt file to be read
            char data[100];
            // get 100 bytes of data from the data.txt file and store it in the data variable
            // also check if fgets == NULL, if so there is a possibility there was an error with fgets
            if(fgets(data, 100, inFile) == NULL){
                // check if file stream for an error to confirm if there was an error with fgets, and if so print
                // an error and halt the server operation by exiting because this is a critical error
                if (ferror(inFile)) {
                    printf("Error: server could not read from the file \"data.txt\"\nServer shutting down...\n");
                    exit(1);
                }
            }

            // loop until EOF is reached and thus feof returns 1
            while(feof(inFile)!=1){

                // sending the data to the client

                // sending with: socket2, message: data, size of message which is 100 bytes for the data, 0 as the flag
                sCount = send(socket2, data, 100, 0);

                // (reuse the sCount variable to monitor how many bits sent and sending status)
                // if sCount == -1 that means the send failed so print an error, and close the client socket. Then use
                // continue on the while loop to allow the server to listen for new clients
                if(sCount == -1){
                    printf("Error: unable to send data from the \"data.txt\" file to the client on port %d\n", port);
                    printf("Server will now restart and begin listening for new clients...\n\n");

                    // closing the client socket
                    close(socket2);

                    // close file
                    fclose(inFile);

                    // start loop again
                    continue;
                }

                // get 100 bytes of data from the data.txt file and store it in the data variable
                // also check if fgets == NULL, if so there is a possibility there was an error with fgets
                if(fgets(data, 100, inFile) == NULL){
                    // check if file stream for an error to confirm if there was an error with fgets, and if so print
                    // an error and halt the server operation by exiting because this is a critical error
                    if (ferror(inFile)) {
                        printf("Error: server could not read from the file \"data.txt\"\nServer shutting down...\n");
                        exit(1);
                    }
                }

            }


            // sending a special flag (that is unlikely to ever be present anywhere else hence the random capitalization)
            // to the client to indicate end of transmission

            // sending with: socket2, message: special flag, size of message which is 10 bytes for the endMarker, 0 as the flag
            sCount = send(socket2, "\r\r\r\r\rEOF - END oF FiLe hAs beEn rEacHed!!!", 43, 0);

            // (reuse the sCount variable to monitor how many bits sent and sending status)
            // if sCount == -1 that means the send failed so print an error, then close the client socket and use continue
            // on the while loop to begin listening for new clients
            if(sCount == -1){
                printf("Error: unable to send EOF flag to the client on port %d\n", port);
                printf("Server will now restart and begin listening for new clients...\n\n");

                // closing the client socket
                close(socket2);

                // close file
                fclose(inFile);

                // start loop again
                continue;
            }

            // close file
            fclose(inFile);

            // closing the client socket
            close(socket2);

            // if the passcodes do not match then print an error message, then close the socket and use continue to loop
            // again and listen for new clients
        }else{
            printf("Error: The client generated passcode does not match the server generated passcode!\n");
            printf("Server will now restart and begin listening for new clients...\n\n");
            // closing the client socket
            close(socket2);

            continue;
        }

        //printing a newline to clean up terminal output
        printf("\n");
    }
    // return statement for the main function - it will never be used due to the infinite while loop
    return 0;
}
